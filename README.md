# 求第一类和第二类完全椭圆积分


三种写法：
## 1. Fortran调C++
调用C++中的``comp_ellint_1f``和``comp_ellint_2f``函数

文件：``ellint.cpp``、``ellintinterface.f90``

用法：
```f90
call ellint(k,f,e)
```
输入：``k``，要求$0 \leq k \leq 1$，需要是``real(8)``或者``real(c_double)``类型

输出：``f``是第一类结果，``e``是第二类结果

## 2. Fortran function
改编自徐士良《FORTRAN常用算法程序集》中的F77程序（两个FOR文件）

文件：``ellintfunction.f90``

用法：
```f90
PI=3.141592653589793238D0
f=melp1(k,PI/2.d0)
e=melp2(k,PI/2.d0)
```
输入：``k``，要求$0 \leq k \geq 1$，第二个参数如果不是``PI/2.d0``则为不完全椭圆积分

输出：``f``是第一类结果，``e``是第二类结果
## 3. Fortran subroutine
将function中分别求一阶二阶的函数合并循环来加快速度

文件：``ellintsubmodule.f90``

用法：
```f90
call melp(k,PI/2.d0,f,e)
```
输入：``k``，要求$0 \leq k \geq 1$，第二个参数如果不是``PI/2.d0``则为不完全椭圆积分

输出：``f``是第一类结果，``e``是第二类结果

## 精度和速度测试

k=0.0~1.0测试结果：
```
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.0    0.1570796490E+01    0.1570796327E+01    0.1570796327E+01    0.1570796490E+01    0.1570796327E+01    0.1570796327E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.1    0.1574745536E+01    0.1574745562E+01    0.1574745562E+01    0.1566861868E+01    0.1566861942E+01    0.1566861942E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.2    0.1586867809E+01    0.1586867848E+01    0.1586867848E+01    0.1554968476E+01    0.1554968546E+01    0.1554968546E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.3    0.1608048677E+01    0.1608048623E+01    0.1608048623E+01    0.1534833431E+01    0.1534833462E+01    0.1534833462E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.4    0.1639999866E+01    0.1639999868E+01    0.1639999868E+01    0.1505941629E+01    0.1505941610E+01    0.1505941610E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.5    0.1685750246E+01    0.1685750355E+01    0.1685750355E+01    0.1467462182E+01    0.1467462209E+01    0.1467462209E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.6    0.1750753760E+01    0.1750753821E+01    0.1750753821E+01    0.1418083310E+01    0.1418083381E+01    0.1418083381E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.7    0.1845694065E+01    0.1845693985E+01    0.1845693985E+01    0.1355661154E+01    0.1355661144E+01    0.1355661144E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.8    0.1995302796E+01    0.1995302801E+01    0.1995302801E+01    0.1276349902E+01    0.1276349932E+01    0.1276349933E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     0.9    0.2280549288E+01    0.2280549293E+01    0.2280549293E+01    0.1171697021E+01    0.1171697009E+01    0.1171697009E+01
     k           F(k)(C++)       F(k)(F90func)       F(k)(F90subr)           E(k)(C++)       E(k)(F90func)       E(k)(F90subr)
     1.0                 NaN    0.8720254124E+01    0.8720254124E+01    0.1000000000E+01    0.1000000000E+01    0.1000000000E+01
```

速度测试，计算10000000次
```
                    test loop:    10000000
                     C++ Time:       3.1541790000000001
            F90 Function Time:      21.1095609999999994
          F90 Subroutine Time:      14.2170570000000005
```